"use strict";(self.webpackChunkucbugg_site=self.webpackChunkucbugg_site||[]).push([[339],{31973:(t,e,i)=>{i.d(e,{Z:()=>p});var n=i(58168),o=i(58240),s=i(9950),r=i(13437),a=Object.defineProperty,h=(t,e,i)=>(((t,e,i)=>{e in t?a(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i})(t,"symbol"!==typeof e?e+"":e,i),i);class l extends r.Object3D{constructor(t,e){super(),h(this,"isTransformControls",!0),h(this,"visible",!1),h(this,"domElement"),h(this,"raycaster",new r.Raycaster),h(this,"gizmo"),h(this,"plane"),h(this,"tempVector",new r.Vector3),h(this,"tempVector2",new r.Vector3),h(this,"tempQuaternion",new r.Quaternion),h(this,"unit",{X:new r.Vector3(1,0,0),Y:new r.Vector3(0,1,0),Z:new r.Vector3(0,0,1)}),h(this,"pointStart",new r.Vector3),h(this,"pointEnd",new r.Vector3),h(this,"offset",new r.Vector3),h(this,"rotationAxis",new r.Vector3),h(this,"startNorm",new r.Vector3),h(this,"endNorm",new r.Vector3),h(this,"rotationAngle",0),h(this,"cameraPosition",new r.Vector3),h(this,"cameraQuaternion",new r.Quaternion),h(this,"cameraScale",new r.Vector3),h(this,"parentPosition",new r.Vector3),h(this,"parentQuaternion",new r.Quaternion),h(this,"parentQuaternionInv",new r.Quaternion),h(this,"parentScale",new r.Vector3),h(this,"worldPositionStart",new r.Vector3),h(this,"worldQuaternionStart",new r.Quaternion),h(this,"worldScaleStart",new r.Vector3),h(this,"worldPosition",new r.Vector3),h(this,"worldQuaternion",new r.Quaternion),h(this,"worldQuaternionInv",new r.Quaternion),h(this,"worldScale",new r.Vector3),h(this,"eye",new r.Vector3),h(this,"positionStart",new r.Vector3),h(this,"quaternionStart",new r.Quaternion),h(this,"scaleStart",new r.Vector3),h(this,"camera"),h(this,"object"),h(this,"enabled",!0),h(this,"axis",null),h(this,"mode","translate"),h(this,"translationSnap",null),h(this,"rotationSnap",null),h(this,"scaleSnap",null),h(this,"space","world"),h(this,"size",1),h(this,"dragging",!1),h(this,"showX",!0),h(this,"showY",!0),h(this,"showZ",!0),h(this,"changeEvent",{type:"change"}),h(this,"mouseDownEvent",{type:"mouseDown",mode:this.mode}),h(this,"mouseUpEvent",{type:"mouseUp",mode:this.mode}),h(this,"objectChangeEvent",{type:"objectChange"}),h(this,"intersectObjectWithRay",((t,e,i)=>{const n=e.intersectObject(t,!0);for(let o=0;o<n.length;o++)if(n[o].object.visible||i)return n[o];return!1})),h(this,"attach",(t=>(this.object=t,this.visible=!0,this))),h(this,"detach",(()=>(this.object=void 0,this.visible=!1,this.axis=null,this))),h(this,"reset",(()=>this.enabled?(this.dragging&&void 0!==this.object&&(this.object.position.copy(this.positionStart),this.object.quaternion.copy(this.quaternionStart),this.object.scale.copy(this.scaleStart),this.dispatchEvent(this.changeEvent),this.dispatchEvent(this.objectChangeEvent),this.pointStart.copy(this.pointEnd)),this):this)),h(this,"updateMatrixWorld",(()=>{void 0!==this.object&&(this.object.updateMatrixWorld(),null===this.object.parent?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this.parentPosition,this.parentQuaternion,this.parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this.worldScale),this.parentQuaternionInv.copy(this.parentQuaternion).invert(),this.worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this.cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld()})),h(this,"pointerHover",(t=>{if(void 0===this.object||!0===this.dragging)return;this.raycaster.setFromCamera(t,this.camera);const e=this.intersectObjectWithRay(this.gizmo.picker[this.mode],this.raycaster);this.axis=e?e.object.name:null})),h(this,"pointerDown",(t=>{if(void 0!==this.object&&!0!==this.dragging&&0===t.button&&null!==this.axis){this.raycaster.setFromCamera(t,this.camera);const e=this.intersectObjectWithRay(this.plane,this.raycaster,!0);if(e){let t=this.space;if("scale"===this.mode?t="local":"E"!==this.axis&&"XYZE"!==this.axis&&"XYZ"!==this.axis||(t="world"),"local"===t&&"rotate"===this.mode){const t=this.rotationSnap;"X"===this.axis&&t&&(this.object.rotation.x=Math.round(this.object.rotation.x/t)*t),"Y"===this.axis&&t&&(this.object.rotation.y=Math.round(this.object.rotation.y/t)*t),"Z"===this.axis&&t&&(this.object.rotation.z=Math.round(this.object.rotation.z/t)*t)}this.object.updateMatrixWorld(),this.object.parent&&this.object.parent.updateMatrixWorld(),this.positionStart.copy(this.object.position),this.quaternionStart.copy(this.object.quaternion),this.scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this.worldScaleStart),this.pointStart.copy(e.point).sub(this.worldPositionStart)}this.dragging=!0,this.mouseDownEvent.mode=this.mode,this.dispatchEvent(this.mouseDownEvent)}})),h(this,"pointerMove",(t=>{const e=this.axis,i=this.mode,n=this.object;let o=this.space;if("scale"===i?o="local":"E"!==e&&"XYZE"!==e&&"XYZ"!==e||(o="world"),void 0===n||null===e||!1===this.dragging||-1!==t.button)return;this.raycaster.setFromCamera(t,this.camera);const s=this.intersectObjectWithRay(this.plane,this.raycaster,!0);if(s){if(this.pointEnd.copy(s.point).sub(this.worldPositionStart),"translate"===i)this.offset.copy(this.pointEnd).sub(this.pointStart),"local"===o&&"XYZ"!==e&&this.offset.applyQuaternion(this.worldQuaternionInv),-1===e.indexOf("X")&&(this.offset.x=0),-1===e.indexOf("Y")&&(this.offset.y=0),-1===e.indexOf("Z")&&(this.offset.z=0),"local"===o&&"XYZ"!==e?this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale):this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale),n.position.copy(this.offset).add(this.positionStart),this.translationSnap&&("local"===o&&(n.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()),-1!==e.search("X")&&(n.position.x=Math.round(n.position.x/this.translationSnap)*this.translationSnap),-1!==e.search("Y")&&(n.position.y=Math.round(n.position.y/this.translationSnap)*this.translationSnap),-1!==e.search("Z")&&(n.position.z=Math.round(n.position.z/this.translationSnap)*this.translationSnap),n.position.applyQuaternion(this.quaternionStart)),"world"===o&&(n.parent&&n.position.add(this.tempVector.setFromMatrixPosition(n.parent.matrixWorld)),-1!==e.search("X")&&(n.position.x=Math.round(n.position.x/this.translationSnap)*this.translationSnap),-1!==e.search("Y")&&(n.position.y=Math.round(n.position.y/this.translationSnap)*this.translationSnap),-1!==e.search("Z")&&(n.position.z=Math.round(n.position.z/this.translationSnap)*this.translationSnap),n.parent&&n.position.sub(this.tempVector.setFromMatrixPosition(n.parent.matrixWorld))));else if("scale"===i){if(-1!==e.search("XYZ")){let t=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(t*=-1),this.tempVector2.set(t,t,t)}else this.tempVector.copy(this.pointStart),this.tempVector2.copy(this.pointEnd),this.tempVector.applyQuaternion(this.worldQuaternionInv),this.tempVector2.applyQuaternion(this.worldQuaternionInv),this.tempVector2.divide(this.tempVector),-1===e.search("X")&&(this.tempVector2.x=1),-1===e.search("Y")&&(this.tempVector2.y=1),-1===e.search("Z")&&(this.tempVector2.z=1);n.scale.copy(this.scaleStart).multiply(this.tempVector2),this.scaleSnap&&this.object&&(-1!==e.search("X")&&(this.object.scale.x=Math.round(n.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==e.search("Y")&&(n.scale.y=Math.round(n.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==e.search("Z")&&(n.scale.z=Math.round(n.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if("rotate"===i){this.offset.copy(this.pointEnd).sub(this.pointStart);const t=20/this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));"E"===e?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this.startNorm.copy(this.pointStart).normalize(),this.endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this.endNorm.cross(this.startNorm).dot(this.eye)<0?1:-1):"XYZE"===e?(this.rotationAxis.copy(this.offset).cross(this.eye).normalize(),this.rotationAngle=this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye))*t):"X"!==e&&"Y"!==e&&"Z"!==e||(this.rotationAxis.copy(this.unit[e]),this.tempVector.copy(this.unit[e]),"local"===o&&this.tempVector.applyQuaternion(this.worldQuaternion),this.rotationAngle=this.offset.dot(this.tempVector.cross(this.eye).normalize())*t),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),"local"===o&&"E"!==e&&"XYZE"!==e?(n.quaternion.copy(this.quaternionStart),n.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this.parentQuaternionInv),n.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),n.quaternion.multiply(this.quaternionStart).normalize())}this.dispatchEvent(this.changeEvent),this.dispatchEvent(this.objectChangeEvent)}})),h(this,"pointerUp",(t=>{0===t.button&&(this.dragging&&null!==this.axis&&(this.mouseUpEvent.mode=this.mode,this.dispatchEvent(this.mouseUpEvent)),this.dragging=!1,this.axis=null)})),h(this,"getPointer",(t=>{var e;if(this.domElement&&(null==(e=this.domElement.ownerDocument)?void 0:e.pointerLockElement))return{x:0,y:0,button:t.button};{const e=t.changedTouches?t.changedTouches[0]:t,i=this.domElement.getBoundingClientRect();return{x:(e.clientX-i.left)/i.width*2-1,y:-(e.clientY-i.top)/i.height*2+1,button:t.button}}})),h(this,"onPointerHover",(t=>{if(this.enabled)switch(t.pointerType){case"mouse":case"pen":this.pointerHover(this.getPointer(t))}})),h(this,"onPointerDown",(t=>{this.enabled&&this.domElement&&(this.domElement.style.touchAction="none",this.domElement.ownerDocument.addEventListener("pointermove",this.onPointerMove),this.pointerHover(this.getPointer(t)),this.pointerDown(this.getPointer(t)))})),h(this,"onPointerMove",(t=>{this.enabled&&this.pointerMove(this.getPointer(t))})),h(this,"onPointerUp",(t=>{this.enabled&&this.domElement&&(this.domElement.style.touchAction="",this.domElement.ownerDocument.removeEventListener("pointermove",this.onPointerMove),this.pointerUp(this.getPointer(t)))})),h(this,"getMode",(()=>this.mode)),h(this,"setMode",(t=>{this.mode=t})),h(this,"setTranslationSnap",(t=>{this.translationSnap=t})),h(this,"setRotationSnap",(t=>{this.rotationSnap=t})),h(this,"setScaleSnap",(t=>{this.scaleSnap=t})),h(this,"setSize",(t=>{this.size=t})),h(this,"setSpace",(t=>{this.space=t})),h(this,"update",(()=>{console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")})),h(this,"connect",(t=>{t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.domElement=t,this.domElement.addEventListener("pointerdown",this.onPointerDown),this.domElement.addEventListener("pointermove",this.onPointerHover),this.domElement.ownerDocument.addEventListener("pointerup",this.onPointerUp)})),h(this,"dispose",(()=>{var t,e,i,n,o,s;null==(t=this.domElement)||t.removeEventListener("pointerdown",this.onPointerDown),null==(e=this.domElement)||e.removeEventListener("pointermove",this.onPointerHover),null==(n=null==(i=this.domElement)?void 0:i.ownerDocument)||n.removeEventListener("pointermove",this.onPointerMove),null==(s=null==(o=this.domElement)?void 0:o.ownerDocument)||s.removeEventListener("pointerup",this.onPointerUp),this.traverse((t=>{const e=t;e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}))})),this.domElement=e,this.camera=t,this.gizmo=new c,this.add(this.gizmo),this.plane=new u,this.add(this.plane);const i=(t,e)=>{let i=e;Object.defineProperty(this,t,{get:function(){return void 0!==i?i:e},set:function(e){i!==e&&(i=e,this.plane[t]=e,this.gizmo[t]=e,this.dispatchEvent({type:t+"-changed",value:e}),this.dispatchEvent(this.changeEvent))}}),this[t]=e,this.plane[t]=e,this.gizmo[t]=e};i("camera",this.camera),i("object",this.object),i("enabled",this.enabled),i("axis",this.axis),i("mode",this.mode),i("translationSnap",this.translationSnap),i("rotationSnap",this.rotationSnap),i("scaleSnap",this.scaleSnap),i("space",this.space),i("size",this.size),i("dragging",this.dragging),i("showX",this.showX),i("showY",this.showY),i("showZ",this.showZ),i("worldPosition",this.worldPosition),i("worldPositionStart",this.worldPositionStart),i("worldQuaternion",this.worldQuaternion),i("worldQuaternionStart",this.worldQuaternionStart),i("cameraPosition",this.cameraPosition),i("cameraQuaternion",this.cameraQuaternion),i("pointStart",this.pointStart),i("pointEnd",this.pointEnd),i("rotationAxis",this.rotationAxis),i("rotationAngle",this.rotationAngle),i("eye",this.eye),void 0!==e&&this.connect(e)}}class c extends r.Object3D{constructor(){super(),h(this,"isTransformControlsGizmo",!0),h(this,"type","TransformControlsGizmo"),h(this,"tempVector",new r.Vector3(0,0,0)),h(this,"tempEuler",new r.Euler),h(this,"alignVector",new r.Vector3(0,1,0)),h(this,"zeroVector",new r.Vector3(0,0,0)),h(this,"lookAtMatrix",new r.Matrix4),h(this,"tempQuaternion",new r.Quaternion),h(this,"tempQuaternion2",new r.Quaternion),h(this,"identityQuaternion",new r.Quaternion),h(this,"unitX",new r.Vector3(1,0,0)),h(this,"unitY",new r.Vector3(0,1,0)),h(this,"unitZ",new r.Vector3(0,0,1)),h(this,"gizmo"),h(this,"picker"),h(this,"helper"),h(this,"rotationAxis",new r.Vector3),h(this,"cameraPosition",new r.Vector3),h(this,"worldPositionStart",new r.Vector3),h(this,"worldQuaternionStart",new r.Quaternion),h(this,"worldPosition",new r.Vector3),h(this,"worldQuaternion",new r.Quaternion),h(this,"eye",new r.Vector3),h(this,"camera",null),h(this,"enabled",!0),h(this,"axis",null),h(this,"mode","translate"),h(this,"space","world"),h(this,"size",1),h(this,"dragging",!1),h(this,"showX",!0),h(this,"showY",!0),h(this,"showZ",!0),h(this,"updateMatrixWorld",(()=>{let t=this.space;"scale"===this.mode&&(t="local");const e="local"===t?this.worldQuaternion:this.identityQuaternion;this.gizmo.translate.visible="translate"===this.mode,this.gizmo.rotate.visible="rotate"===this.mode,this.gizmo.scale.visible="scale"===this.mode,this.helper.translate.visible="translate"===this.mode,this.helper.rotate.visible="rotate"===this.mode,this.helper.scale.visible="scale"===this.mode;let i=[];i=i.concat(this.picker[this.mode].children),i=i.concat(this.gizmo[this.mode].children),i=i.concat(this.helper[this.mode].children);for(let n=0;n<i.length;n++){const t=i[n];let o;if(t.visible=!0,t.rotation.set(0,0,0),t.position.copy(this.worldPosition),o=this.camera.isOrthographicCamera?(this.camera.top-this.camera.bottom)/this.camera.zoom:this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),t.scale.set(1,1,1).multiplyScalar(o*this.size/7),"helper"!==t.tag){if(t.quaternion.copy(e),"translate"===this.mode||"scale"===this.mode){const i=.99,n=.2,o=0;"X"!==t.name&&"XYZX"!==t.name||Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(e).dot(this.eye))>i&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),"Y"!==t.name&&"XYZY"!==t.name||Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(e).dot(this.eye))>i&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),"Z"!==t.name&&"XYZZ"!==t.name||Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(e).dot(this.eye))>i&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),"XY"===t.name&&Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(e).dot(this.eye))<n&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),"YZ"===t.name&&Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(e).dot(this.eye))<n&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),"XZ"===t.name&&Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(e).dot(this.eye))<n&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),-1!==t.name.search("X")&&(this.alignVector.copy(this.unitX).applyQuaternion(e).dot(this.eye)<o?"fwd"===t.tag?t.visible=!1:t.scale.x*=-1:"bwd"===t.tag&&(t.visible=!1)),-1!==t.name.search("Y")&&(this.alignVector.copy(this.unitY).applyQuaternion(e).dot(this.eye)<o?"fwd"===t.tag?t.visible=!1:t.scale.y*=-1:"bwd"===t.tag&&(t.visible=!1)),-1!==t.name.search("Z")&&(this.alignVector.copy(this.unitZ).applyQuaternion(e).dot(this.eye)<o?"fwd"===t.tag?t.visible=!1:t.scale.z*=-1:"bwd"===t.tag&&(t.visible=!1))}else"rotate"===this.mode&&(this.tempQuaternion2.copy(e),this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(e).invert()),-1!==t.name.search("E")&&t.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye,this.zeroVector,this.unitY)),"X"===t.name&&(this.tempQuaternion.setFromAxisAngle(this.unitX,Math.atan2(-this.alignVector.y,this.alignVector.z)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),t.quaternion.copy(this.tempQuaternion)),"Y"===t.name&&(this.tempQuaternion.setFromAxisAngle(this.unitY,Math.atan2(this.alignVector.x,this.alignVector.z)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),t.quaternion.copy(this.tempQuaternion)),"Z"===t.name&&(this.tempQuaternion.setFromAxisAngle(this.unitZ,Math.atan2(this.alignVector.y,this.alignVector.x)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),t.quaternion.copy(this.tempQuaternion)));t.visible=t.visible&&(-1===t.name.indexOf("X")||this.showX),t.visible=t.visible&&(-1===t.name.indexOf("Y")||this.showY),t.visible=t.visible&&(-1===t.name.indexOf("Z")||this.showZ),t.visible=t.visible&&(-1===t.name.indexOf("E")||this.showX&&this.showY&&this.showZ),t.material.tempOpacity=t.material.tempOpacity||t.material.opacity,t.material.tempColor=t.material.tempColor||t.material.color.clone(),t.material.color.copy(t.material.tempColor),t.material.opacity=t.material.tempOpacity,this.enabled?this.axis&&(t.name===this.axis||this.axis.split("").some((function(e){return t.name===e}))?(t.material.opacity=1,t.material.color.lerp(new r.Color(1,1,1),.5)):(t.material.opacity*=.25,t.material.color.lerp(new r.Color(1,1,1),.5))):(t.material.opacity*=.5,t.material.color.lerp(new r.Color(1,1,1),.5))}else t.visible=!1,"AXIS"===t.name?(t.position.copy(this.worldPositionStart),t.visible=!!this.axis,"X"===this.axis&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,0,0)),t.quaternion.copy(e).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(e).dot(this.eye))>.9&&(t.visible=!1)),"Y"===this.axis&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,0,Math.PI/2)),t.quaternion.copy(e).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(e).dot(this.eye))>.9&&(t.visible=!1)),"Z"===this.axis&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,Math.PI/2,0)),t.quaternion.copy(e).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(e).dot(this.eye))>.9&&(t.visible=!1)),"XYZE"===this.axis&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,Math.PI/2,0)),this.alignVector.copy(this.rotationAxis),t.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.zeroVector,this.alignVector,this.unitY)),t.quaternion.multiply(this.tempQuaternion),t.visible=this.dragging),"E"===this.axis&&(t.visible=!1)):"START"===t.name?(t.position.copy(this.worldPositionStart),t.visible=this.dragging):"END"===t.name?(t.position.copy(this.worldPosition),t.visible=this.dragging):"DELTA"===t.name?(t.position.copy(this.worldPositionStart),t.quaternion.copy(this.worldQuaternionStart),this.tempVector.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()),t.scale.copy(this.tempVector),t.visible=this.dragging):(t.quaternion.copy(e),this.dragging?t.position.copy(this.worldPositionStart):t.position.copy(this.worldPosition),this.axis&&(t.visible=-1!==this.axis.search(t.name)))}super.updateMatrixWorld()}));const t=new r.MeshBasicMaterial({depthTest:!1,depthWrite:!1,transparent:!0,side:r.DoubleSide,fog:!1,toneMapped:!1}),e=new r.LineBasicMaterial({depthTest:!1,depthWrite:!1,transparent:!0,linewidth:1,fog:!1,toneMapped:!1}),i=t.clone();i.opacity=.15;const n=t.clone();n.opacity=.33;const o=t.clone();o.color.set(16711680);const s=t.clone();s.color.set(65280);const a=t.clone();a.color.set(255);const l=t.clone();l.opacity=.25;const c=l.clone();c.color.set(16776960);const u=l.clone();u.color.set(65535);const p=l.clone();p.color.set(16711935);t.clone().color.set(16776960);const d=e.clone();d.color.set(16711680);const m=e.clone();m.color.set(65280);const f=e.clone();f.color.set(255);const w=e.clone();w.color.set(65535);const y=e.clone();y.color.set(16711935);const g=e.clone();g.color.set(16776960);const v=e.clone();v.color.set(7895160);const b=g.clone();b.opacity=.25;const M=new r.CylinderGeometry(0,.05,.2,12,1,!1),x=new r.BoxGeometry(.125,.125,.125),E=new r.BufferGeometry;E.setAttribute("position",new r.Float32BufferAttribute([0,0,0,1,0,0],3));const S=(t,e)=>{const i=new r.BufferGeometry,n=[];for(let o=0;o<=64*e;++o)n.push(0,Math.cos(o/32*Math.PI)*t,Math.sin(o/32*Math.PI)*t);return i.setAttribute("position",new r.Float32BufferAttribute(n,3)),i},P={X:[[new r.Mesh(M,o),[1,0,0],[0,0,-Math.PI/2],null,"fwd"],[new r.Mesh(M,o),[1,0,0],[0,0,Math.PI/2],null,"bwd"],[new r.Line(E,d)]],Y:[[new r.Mesh(M,s),[0,1,0],null,null,"fwd"],[new r.Mesh(M,s),[0,1,0],[Math.PI,0,0],null,"bwd"],[new r.Line(E,m),null,[0,0,Math.PI/2]]],Z:[[new r.Mesh(M,a),[0,0,1],[Math.PI/2,0,0],null,"fwd"],[new r.Mesh(M,a),[0,0,1],[-Math.PI/2,0,0],null,"bwd"],[new r.Line(E,f),null,[0,-Math.PI/2,0]]],XYZ:[[new r.Mesh(new r.OctahedronGeometry(.1,0),l.clone()),[0,0,0],[0,0,0]]],XY:[[new r.Mesh(new r.PlaneGeometry(.295,.295),c.clone()),[.15,.15,0]],[new r.Line(E,g),[.18,.3,0],null,[.125,1,1]],[new r.Line(E,g),[.3,.18,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new r.Mesh(new r.PlaneGeometry(.295,.295),u.clone()),[0,.15,.15],[0,Math.PI/2,0]],[new r.Line(E,w),[0,.18,.3],[0,0,Math.PI/2],[.125,1,1]],[new r.Line(E,w),[0,.3,.18],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new r.Mesh(new r.PlaneGeometry(.295,.295),p.clone()),[.15,0,.15],[-Math.PI/2,0,0]],[new r.Line(E,y),[.18,0,.3],null,[.125,1,1]],[new r.Line(E,y),[.3,0,.18],[0,-Math.PI/2,0],[.125,1,1]]]},Q={X:[[new r.Mesh(new r.CylinderGeometry(.2,0,1,4,1,!1),i),[.6,0,0],[0,0,-Math.PI/2]]],Y:[[new r.Mesh(new r.CylinderGeometry(.2,0,1,4,1,!1),i),[0,.6,0]]],Z:[[new r.Mesh(new r.CylinderGeometry(.2,0,1,4,1,!1),i),[0,0,.6],[Math.PI/2,0,0]]],XYZ:[[new r.Mesh(new r.OctahedronGeometry(.2,0),i)]],XY:[[new r.Mesh(new r.PlaneGeometry(.4,.4),i),[.2,.2,0]]],YZ:[[new r.Mesh(new r.PlaneGeometry(.4,.4),i),[0,.2,.2],[0,Math.PI/2,0]]],XZ:[[new r.Mesh(new r.PlaneGeometry(.4,.4),i),[.2,0,.2],[-Math.PI/2,0,0]]]},V={START:[[new r.Mesh(new r.OctahedronGeometry(.01,2),n),null,null,null,"helper"]],END:[[new r.Mesh(new r.OctahedronGeometry(.01,2),n),null,null,null,"helper"]],DELTA:[[new r.Line((()=>{const t=new r.BufferGeometry;return t.setAttribute("position",new r.Float32BufferAttribute([0,0,0,1,1,1],3)),t})(),n),null,null,null,"helper"]],X:[[new r.Line(E,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new r.Line(E,n.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new r.Line(E,n.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},k={X:[[new r.Line(S(1,.5),d)],[new r.Mesh(new r.OctahedronGeometry(.04,0),o),[0,0,.99],null,[1,3,1]]],Y:[[new r.Line(S(1,.5),m),null,[0,0,-Math.PI/2]],[new r.Mesh(new r.OctahedronGeometry(.04,0),s),[0,0,.99],null,[3,1,1]]],Z:[[new r.Line(S(1,.5),f),null,[0,Math.PI/2,0]],[new r.Mesh(new r.OctahedronGeometry(.04,0),a),[.99,0,0],null,[1,3,1]]],E:[[new r.Line(S(1.25,1),b),null,[0,Math.PI/2,0]],[new r.Mesh(new r.CylinderGeometry(.03,0,.15,4,1,!1),b),[1.17,0,0],[0,0,-Math.PI/2],[1,1,.001]],[new r.Mesh(new r.CylinderGeometry(.03,0,.15,4,1,!1),b),[-1.17,0,0],[0,0,Math.PI/2],[1,1,.001]],[new r.Mesh(new r.CylinderGeometry(.03,0,.15,4,1,!1),b),[0,-1.17,0],[Math.PI,0,0],[1,1,.001]],[new r.Mesh(new r.CylinderGeometry(.03,0,.15,4,1,!1),b),[0,1.17,0],[0,0,0],[1,1,.001]]],XYZE:[[new r.Line(S(1,1),v),null,[0,Math.PI/2,0]]]},Y={AXIS:[[new r.Line(E,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},X={X:[[new r.Mesh(new r.TorusGeometry(1,.1,4,24),i),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new r.Mesh(new r.TorusGeometry(1,.1,4,24),i),[0,0,0],[Math.PI/2,0,0]]],Z:[[new r.Mesh(new r.TorusGeometry(1,.1,4,24),i),[0,0,0],[0,0,-Math.PI/2]]],E:[[new r.Mesh(new r.TorusGeometry(1.25,.1,2,24),i)]],XYZE:[[new r.Mesh(new r.SphereGeometry(.7,10,8),i)]]},Z={X:[[new r.Mesh(x,o),[.8,0,0],[0,0,-Math.PI/2]],[new r.Line(E,d),null,null,[.8,1,1]]],Y:[[new r.Mesh(x,s),[0,.8,0]],[new r.Line(E,m),null,[0,0,Math.PI/2],[.8,1,1]]],Z:[[new r.Mesh(x,a),[0,0,.8],[Math.PI/2,0,0]],[new r.Line(E,f),null,[0,-Math.PI/2,0],[.8,1,1]]],XY:[[new r.Mesh(x,c),[.85,.85,0],null,[2,2,.2]],[new r.Line(E,g),[.855,.98,0],null,[.125,1,1]],[new r.Line(E,g),[.98,.855,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new r.Mesh(x,u),[0,.85,.85],null,[.2,2,2]],[new r.Line(E,w),[0,.855,.98],[0,0,Math.PI/2],[.125,1,1]],[new r.Line(E,w),[0,.98,.855],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new r.Mesh(x,p),[.85,0,.85],null,[2,.2,2]],[new r.Line(E,y),[.855,0,.98],null,[.125,1,1]],[new r.Line(E,y),[.98,0,.855],[0,-Math.PI/2,0],[.125,1,1]]],XYZX:[[new r.Mesh(new r.BoxGeometry(.125,.125,.125),l.clone()),[1.1,0,0]]],XYZY:[[new r.Mesh(new r.BoxGeometry(.125,.125,.125),l.clone()),[0,1.1,0]]],XYZZ:[[new r.Mesh(new r.BoxGeometry(.125,.125,.125),l.clone()),[0,0,1.1]]]},L={X:[[new r.Mesh(new r.CylinderGeometry(.2,0,.8,4,1,!1),i),[.5,0,0],[0,0,-Math.PI/2]]],Y:[[new r.Mesh(new r.CylinderGeometry(.2,0,.8,4,1,!1),i),[0,.5,0]]],Z:[[new r.Mesh(new r.CylinderGeometry(.2,0,.8,4,1,!1),i),[0,0,.5],[Math.PI/2,0,0]]],XY:[[new r.Mesh(x,i),[.85,.85,0],null,[3,3,.2]]],YZ:[[new r.Mesh(x,i),[0,.85,.85],null,[.2,3,3]]],XZ:[[new r.Mesh(x,i),[.85,0,.85],null,[3,.2,3]]],XYZX:[[new r.Mesh(new r.BoxGeometry(.2,.2,.2),i),[1.1,0,0]]],XYZY:[[new r.Mesh(new r.BoxGeometry(.2,.2,.2),i),[0,1.1,0]]],XYZZ:[[new r.Mesh(new r.BoxGeometry(.2,.2,.2),i),[0,0,1.1]]]},z={X:[[new r.Line(E,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new r.Line(E,n.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new r.Line(E,n.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},I=t=>{const e=new r.Object3D;for(let i in t)for(let n=t[i].length;n--;){const o=t[i][n][0].clone(),s=t[i][n][1],r=t[i][n][2],a=t[i][n][3],h=t[i][n][4];o.name=i,o.tag=h,s&&o.position.set(s[0],s[1],s[2]),r&&o.rotation.set(r[0],r[1],r[2]),a&&o.scale.set(a[0],a[1],a[2]),o.updateMatrix();const l=o.geometry.clone();l.applyMatrix4(o.matrix),o.geometry=l,o.renderOrder=1/0,o.position.set(0,0,0),o.rotation.set(0,0,0),o.scale.set(1,1,1),e.add(o)}return e};this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=I(P)),this.add(this.gizmo.rotate=I(k)),this.add(this.gizmo.scale=I(Z)),this.add(this.picker.translate=I(Q)),this.add(this.picker.rotate=I(X)),this.add(this.picker.scale=I(L)),this.add(this.helper.translate=I(V)),this.add(this.helper.rotate=I(Y)),this.add(this.helper.scale=I(z)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}}class u extends r.Mesh{constructor(){super(new r.PlaneGeometry(1e5,1e5,2,2),new r.MeshBasicMaterial({visible:!1,wireframe:!0,side:r.DoubleSide,transparent:!0,opacity:.1,toneMapped:!1})),h(this,"isTransformControlsPlane",!0),h(this,"type","TransformControlsPlane"),h(this,"unitX",new r.Vector3(1,0,0)),h(this,"unitY",new r.Vector3(0,1,0)),h(this,"unitZ",new r.Vector3(0,0,1)),h(this,"tempVector",new r.Vector3),h(this,"dirVector",new r.Vector3),h(this,"alignVector",new r.Vector3),h(this,"tempMatrix",new r.Matrix4),h(this,"identityQuaternion",new r.Quaternion),h(this,"cameraQuaternion",new r.Quaternion),h(this,"worldPosition",new r.Vector3),h(this,"worldQuaternion",new r.Quaternion),h(this,"eye",new r.Vector3),h(this,"axis",null),h(this,"mode","translate"),h(this,"space","world"),h(this,"updateMatrixWorld",(()=>{let t=this.space;switch(this.position.copy(this.worldPosition),"scale"===this.mode&&(t="local"),this.unitX.set(1,0,0).applyQuaternion("local"===t?this.worldQuaternion:this.identityQuaternion),this.unitY.set(0,1,0).applyQuaternion("local"===t?this.worldQuaternion:this.identityQuaternion),this.unitZ.set(0,0,1).applyQuaternion("local"===t?this.worldQuaternion:this.identityQuaternion),this.alignVector.copy(this.unitY),this.mode){case"translate":case"scale":switch(this.axis){case"X":this.alignVector.copy(this.eye).cross(this.unitX),this.dirVector.copy(this.unitX).cross(this.alignVector);break;case"Y":this.alignVector.copy(this.eye).cross(this.unitY),this.dirVector.copy(this.unitY).cross(this.alignVector);break;case"Z":this.alignVector.copy(this.eye).cross(this.unitZ),this.dirVector.copy(this.unitZ).cross(this.alignVector);break;case"XY":this.dirVector.copy(this.unitZ);break;case"YZ":this.dirVector.copy(this.unitX);break;case"XZ":this.alignVector.copy(this.unitZ),this.dirVector.copy(this.unitY);break;case"XYZ":case"E":this.dirVector.set(0,0,0)}break;default:this.dirVector.set(0,0,0)}0===this.dirVector.length()?this.quaternion.copy(this.cameraQuaternion):(this.tempMatrix.lookAt(this.tempVector.set(0,0,0),this.dirVector,this.alignVector),this.quaternion.setFromRotationMatrix(this.tempMatrix)),super.updateMatrixWorld()}))}}const p=s.forwardRef(((t,e)=>{let{children:i,domElement:a,onChange:h,onMouseDown:c,onMouseUp:u,onObjectChange:p,object:d,makeDefault:m,camera:f,enabled:w,axis:y,mode:g,translationSnap:v,rotationSnap:b,scaleSnap:M,space:x,size:E,showX:S,showY:P,showZ:Q,...V}=t;const k=(0,o.A)((t=>t.controls)),Y=(0,o.A)((t=>t.gl)),X=(0,o.A)((t=>t.events)),Z=(0,o.A)((t=>t.camera)),L=(0,o.A)((t=>t.invalidate)),z=(0,o.A)((t=>t.get)),I=(0,o.A)((t=>t.set)),A=f||Z,j=a||X.connected||Y.domElement,C=s.useMemo((()=>new l(A,j)),[A,j]),O=s.useRef(null);s.useLayoutEffect((()=>(d?C.attach(d instanceof r.Object3D?d:d.current):O.current instanceof r.Object3D&&C.attach(O.current),()=>{C.detach()})),[d,i,C]),s.useEffect((()=>{if(k){const t=t=>k.enabled=!t.value;return C.addEventListener("dragging-changed",t),()=>C.removeEventListener("dragging-changed",t)}}),[C,k]);const q=s.useRef(),G=s.useRef(),D=s.useRef(),W=s.useRef();return s.useLayoutEffect((()=>{q.current=h}),[h]),s.useLayoutEffect((()=>{G.current=c}),[c]),s.useLayoutEffect((()=>{D.current=u}),[u]),s.useLayoutEffect((()=>{W.current=p}),[p]),s.useEffect((()=>{const t=t=>{L(),null==q.current||q.current(t)},e=t=>null==G.current?void 0:G.current(t),i=t=>null==D.current?void 0:D.current(t),n=t=>null==W.current?void 0:W.current(t);return C.addEventListener("change",t),C.addEventListener("mouseDown",e),C.addEventListener("mouseUp",i),C.addEventListener("objectChange",n),()=>{C.removeEventListener("change",t),C.removeEventListener("mouseDown",e),C.removeEventListener("mouseUp",i),C.removeEventListener("objectChange",n)}}),[L,C]),s.useEffect((()=>{if(m){const t=z().controls;return I({controls:C}),()=>I({controls:t})}}),[m,C]),s.createElement(s.Fragment,null,s.createElement("primitive",{ref:e,object:C,enabled:w,axis:y,mode:g,translationSnap:v,rotationSnap:b,scaleSnap:M,space:x,size:E,showX:S,showY:P,showZ:Q}),s.createElement("group",(0,n.A)({ref:O},V),i))}))},25059:(t,e,i)=>{i.d(e,{p:()=>w});var n=i(58168),o=i(9950),s=i(13437),r=i(58240);function a(t,e,i,n){const o=class extends s.ShaderMaterial{constructor(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=Object.entries(t);super({uniforms:r.reduce(((t,e)=>{let[i,n]=e;return{...t,...s.UniformsUtils.clone({[i]:{value:n}})}}),{}),vertexShader:e,fragmentShader:i}),this.key="",r.forEach((t=>{let[e]=t;return Object.defineProperty(this,e,{get:()=>this.uniforms[e].value,set:t=>this.uniforms[e].value=t})})),Object.assign(this,o),n&&n(this)}};return o.key=s.MathUtils.generateUUID(),o}const h={uniforms:{strokeOpacity:1,fillOpacity:.25,fillMix:0,thickness:.05,colorBackfaces:!1,dashInvert:!0,dash:!1,dashRepeats:4,dashLength:.5,squeeze:!1,squeezeMin:.2,squeezeMax:1,stroke:new s.Color("#ff0000"),backfaceStroke:new s.Color("#0000ff"),fill:new s.Color("#00ff00")},vertex:"\n\t  attribute vec3 barycentric;\n\t\n\t\tvarying vec3 v_edges_Barycentric;\n\t\tvarying vec3 v_edges_Position;\n\n\t\tvoid initWireframe() {\n\t\t\tv_edges_Barycentric = barycentric;\n\t\t\tv_edges_Position = position.xyz;\n\t\t}\n\t  ",fragment:"\n\t\t#ifndef PI\n\t  \t#define PI 3.1415926535897932384626433832795\n\t\t#endif\n  \n\t  varying vec3 v_edges_Barycentric;\n\t  varying vec3 v_edges_Position;\n  \n\t  uniform float strokeOpacity;\n\t  uniform float fillOpacity;\n\t  uniform float fillMix;\n\t  uniform float thickness;\n\t  uniform bool colorBackfaces;\n  \n\t  // Dash\n\t  uniform bool dashInvert;\n\t  uniform bool dash;\n\t  uniform bool dashOnly;\n\t  uniform float dashRepeats;\n\t  uniform float dashLength;\n  \n\t  // Squeeze\n\t  uniform bool squeeze;\n\t  uniform float squeezeMin;\n\t  uniform float squeezeMax;\n  \n\t  // Colors\n\t  uniform vec3 stroke;\n\t  uniform vec3 backfaceStroke;\n\t  uniform vec3 fill;\n  \n\t  // This is like\n\t  float wireframe_aastep(float threshold, float dist) {\n\t\t  float afwidth = fwidth(dist) * 0.5;\n\t\t  return smoothstep(threshold - afwidth, threshold + afwidth, dist);\n\t  }\n  \n\t  float wireframe_map(float value, float min1, float max1, float min2, float max2) {\n\t\t  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n\t  }\n  \n\t  float getWireframe() {\n\t\t\tvec3 barycentric = v_edges_Barycentric;\n\t\t\n\t\t\t// Distance from center of each triangle to its edges.\n\t\t\tfloat d = min(min(barycentric.x, barycentric.y), barycentric.z);\n\n\t\t\t// for dashed rendering, we can use this to get the 0 .. 1 value of the line length\n\t\t\tfloat positionAlong = max(barycentric.x, barycentric.y);\n\t\t\tif (barycentric.y < barycentric.x && barycentric.y < barycentric.z) {\n\t\t\t\tpositionAlong = 1.0 - positionAlong;\n\t\t\t}\n\n\t\t\t// the thickness of the stroke\n\t\t\tfloat computedThickness = wireframe_map(thickness, 0.0, 1.0, 0.0, 0.34);\n\n\t\t\t// if we want to shrink the thickness toward the center of the line segment\n\t\t\tif (squeeze) {\n\t\t\t\tcomputedThickness *= mix(squeezeMin, squeezeMax, (1.0 - sin(positionAlong * PI)));\n\t\t\t}\n\n\t\t\t// Create dash pattern\n\t\t\tif (dash) {\n\t\t\t\t// here we offset the stroke position depending on whether it\n\t\t\t\t// should overlap or not\n\t\t\t\tfloat offset = 1.0 / dashRepeats * dashLength / 2.0;\n\t\t\t\tif (!dashInvert) {\n\t\t\t\t\toffset += 1.0 / dashRepeats / 2.0;\n\t\t\t\t}\n\n\t\t\t\t// if we should animate the dash or not\n\t\t\t\t// if (dashAnimate) {\n\t\t\t\t// \toffset += time * 0.22;\n\t\t\t\t// }\n\n\t\t\t\t// create the repeating dash pattern\n\t\t\t\tfloat pattern = fract((positionAlong + offset) * dashRepeats);\n\t\t\t\tcomputedThickness *= 1.0 - wireframe_aastep(dashLength, pattern);\n\t\t\t}\n\n\t\t\t// compute the anti-aliased stroke edge  \n\t\t\tfloat edge = 1.0 - wireframe_aastep(computedThickness, d);\n\n\t\t\treturn edge;\n\t  }\n\t  "},l=a(h.uniforms,h.vertex+"\n  \tvoid main() {\n\t\tinitWireframe();\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t}\n  ",h.fragment+"\n  void main () {\n\t\t// Compute color\n\n\t\tfloat edge = getWireframe();\n\t\tvec4 colorStroke = vec4(stroke, edge);\n\n\t\t#ifdef FLIP_SIDED\n\t\t\tcolorStroke.rgb = backfaceStroke;\n\t\t#endif\n    \n\t\tvec4 colorFill = vec4(fill, fillOpacity);\n\t\tvec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\n\n\t\tgl_FragColor = outColor;\n\t}\n  ");function c(t){return void 0!==(null==t?void 0:t.current)}function u(t){return"WireframeGeometry"===t.type}function p(t){const e=null!=(i=t)&&i.current?t.current:t;var i;if(function(t){return!(null==t||!t.isBufferGeometry)}(e))return e;{if(u(e))throw new Error("Wireframe: WireframeGeometry is not supported.");const t=e.parent;if(function(t){return!(null==t||!t.geometry)}(t)){if(u(t.geometry))throw new Error("Wireframe: WireframeGeometry is not supported.");return t.geometry}}}function d(t,e){if(t.index){console.warn("Wireframe: Requires non-indexed geometry, converting to non-indexed geometry.");const e=t.toNonIndexed();t.copy(e),t.setIndex(null)}const i=function(t,e){const i=t.getAttribute("position").count,n=[];for(let o=0;o<i;o++){const t=e?1:0;o%2===0?n.push(0,0,1,0,1,0,1,0,t):n.push(0,1,0,0,0,1,1,0,t)}return new s.BufferAttribute(Float32Array.from(n),3)}(t,e);t.setAttribute("barycentric",i)}function m(t){let{geometry:e,simplify:i=!1,...a}=t;(0,r.e)({MeshWireframeMaterial:l});const[h,u]=o.useState(null);o.useLayoutEffect((()=>{const t=p(e);if(!t)throw new Error("Wireframe: geometry prop must be a BufferGeometry or a ref to a BufferGeometry.");d(t,i),c(e)&&u(t)}),[i,e]);const m=c(e)?h:e;return o.createElement(o.Fragment,null,m&&o.createElement("mesh",{geometry:m},o.createElement("meshWireframeMaterial",(0,n.A)({attach:"material",transparent:!0,side:s.DoubleSide,polygonOffset:!0,polygonOffsetFactor:-4},a,{extensions:{derivatives:!0,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1}}))))}function f(t){let{simplify:e=!1,...i}=t;const n=o.useRef(null),r=o.useMemo((()=>function(){const t={};for(const e in h.uniforms)t[e]={value:h.uniforms[e]};return t}()),[h.uniforms]);return function(t,e){o.useEffect((()=>{var i;t.fillOpacity.value=null!==(i=e.fillOpacity)&&void 0!==i?i:t.fillOpacity.value}),[e.fillOpacity]),o.useEffect((()=>{var i;t.fillMix.value=null!==(i=e.fillMix)&&void 0!==i?i:t.fillMix.value}),[e.fillMix]),o.useEffect((()=>{var i;t.strokeOpacity.value=null!==(i=e.strokeOpacity)&&void 0!==i?i:t.strokeOpacity.value}),[e.strokeOpacity]),o.useEffect((()=>{var i;t.thickness.value=null!==(i=e.thickness)&&void 0!==i?i:t.thickness.value}),[e.thickness]),o.useEffect((()=>{t.colorBackfaces.value=!!e.colorBackfaces}),[e.colorBackfaces]),o.useEffect((()=>{t.dash.value=!!e.dash}),[e.dash]),o.useEffect((()=>{t.dashInvert.value=!!e.dashInvert}),[e.dashInvert]),o.useEffect((()=>{var i;t.dashRepeats.value=null!==(i=e.dashRepeats)&&void 0!==i?i:t.dashRepeats.value}),[e.dashRepeats]),o.useEffect((()=>{var i;t.dashLength.value=null!==(i=e.dashLength)&&void 0!==i?i:t.dashLength.value}),[e.dashLength]),o.useEffect((()=>{t.squeeze.value=!!e.squeeze}),[e.squeeze]),o.useEffect((()=>{var i;t.squeezeMin.value=null!==(i=e.squeezeMin)&&void 0!==i?i:t.squeezeMin.value}),[e.squeezeMin]),o.useEffect((()=>{var i;t.squeezeMax.value=null!==(i=e.squeezeMax)&&void 0!==i?i:t.squeezeMax.value}),[e.squeezeMax]),o.useEffect((()=>{t.stroke.value=e.stroke?new s.Color(e.stroke):t.stroke.value}),[e.stroke]),o.useEffect((()=>{t.fill.value=e.fill?new s.Color(e.fill):t.fill.value}),[e.fill]),o.useEffect((()=>{t.backfaceStroke.value=e.backfaceStroke?new s.Color(e.backfaceStroke):t.backfaceStroke.value}),[e.backfaceStroke])}(r,i),o.useLayoutEffect((()=>{const t=p(n);if(!t)throw new Error("Wireframe: Must be a child of a Mesh, Line or Points object or specify a geometry prop.");const i=t.clone();return d(t,e),()=>{t.copy(i),i.dispose()}}),[e]),o.useLayoutEffect((()=>{const t=n.current.parent,e=t.material.clone();return function(t,e){t.onBeforeCompile=t=>{t.uniforms={...t.uniforms,...e},t.vertexShader=t.vertexShader.replace("void main() {","\n\t\t  ".concat(h.vertex,"\n\t\t  void main() {\n\t\t\tinitWireframe();\n\t\t")),t.fragmentShader=t.fragmentShader.replace("void main() {","\n\t\t  ".concat(h.fragment,"\n\t\t  void main() {\n\t\t")),t.fragmentShader=t.fragmentShader.replace("#include <color_fragment>","\n\t\t  #include <color_fragment>\n\t\t\t  float edge = getWireframe();\n\t\t  vec4 colorStroke = vec4(stroke, edge);\n\t\t  #ifdef FLIP_SIDED\n\t\t\tcolorStroke.rgb = backfaceStroke;\n\t\t  #endif\n\t\t  vec4 colorFill = vec4(mix(diffuseColor.rgb, fill, fillMix), mix(diffuseColor.a, fillOpacity, fillMix));\n\t\t  vec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\n\n\t\t  diffuseColor.rgb = outColor.rgb;\n\t\t  diffuseColor.a *= outColor.a;\n\t\t")},t.side=s.DoubleSide,t.transparent=!0}(t.material,r),()=>{t.material.dispose(),t.material=e}}),[]),o.createElement("object3D",{ref:n})}function w(t){let{geometry:e,...i}=t;return e?o.createElement(m,(0,n.A)({geometry:e},i)):o.createElement(f,i)}},96192:(t,e,i)=>{i.d(e,{p:()=>r});var n=i(13437),o=i(39298);let s=0;const r=(0,o.A)((t=>(n.DefaultLoadingManager.onStart=(e,i,n)=>{t({active:!0,item:e,loaded:i,total:n,progress:(i-s)/(n-s)*100})},n.DefaultLoadingManager.onLoad=()=>{t({active:!1})},n.DefaultLoadingManager.onError=e=>t((t=>({errors:[...t.errors,e]}))),n.DefaultLoadingManager.onProgress=(e,i,n)=>{i===n&&(s=n),t({active:!0,item:e,loaded:i,total:n,progress:(i-s)/(n-s)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0})))}}]);